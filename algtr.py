# -*- coding: utf-8 -*-
"""algtr.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NTqeONjYG2sLMID5mKg2bu1Y0EvVcd_L
"""

!pip install yfinance numpy pandas scipy matplotlib stable-baselines3 gym
import yfinance as yf
import numpy as np
import pandas as pd
from scipy.stats import norm
import datetime
import matplotlib.pyplot as plt
import gym
from gym import spaces
from stable_baselines3 import PPO

# Black-Scholes model for European Call Option
def black_scholes_call(S, K, T, r, sigma):
    if T <= 0:
        return max(S - K, 0)
    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    call_price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)
    return call_price

# Fetch option chain data using yfinance
def fetch_option_chain(symbol, expiration=None):
    ticker = yf.Ticker(symbol)
    if expiration is None:
        expiration = ticker.options[0]  # fallback to first expiration
    if expiration not in ticker.options:
        raise ValueError(f"Expiration {expiration} not found. Available: {ticker.options}")
    option_chain = ticker.option_chain(expiration)
    calls = option_chain.calls.dropna(subset=['impliedVolatility', 'lastPrice'])
    puts = option_chain.puts.dropna(subset=['impliedVolatility', 'lastPrice'])
    return calls, puts, expiration

# Custom Gym environment for option trading
class OptionTradingEnv(gym.Env):
    """
    Simplified environment to trade a call option from option chain data.
    Observation: [Underlying Price, Strike, Time to Expiry (yrs), Implied Volatility, Option Price]
    Actions: 0 = Hold, 1 = Buy, 2 = Sell
    Reward: Profit and loss from option price changes scaled by position
    """
    metadata = {'render.modes': ['human']}
    def __init__(self, options_df, r=0.01):
        super().__init__()
        self.df = options_df.reset_index(drop=True)
        self.r = r
        self.current_step = 0
        self.position = 0  # No position=0, Long=1, Short=-1
        self.done = False
        self.action_space = spaces.Discrete(3)
        self.observation_space = spaces.Box(low=0, high=np.inf, shape=(5,), dtype=np.float32)

    def reset(self):
        self.current_step = 0
        self.position = 0
        self.done = False
        return self._get_obs()

    def _get_obs(self):
        row = self.df.loc[self.current_step]
        S = row.get("underlyingPrice", 100.0)
        K = row['strike']
        expiration_date = pd.to_datetime(row['expiration'])
        today = pd.to_datetime(datetime.datetime.now().date())
        T = max((expiration_date - today).days / 365, 1e-5)
        iv = row['impliedVolatility']
        price = row['lastPrice']
        return np.array([S, K, T, iv, price], dtype=np.float32)

    def step(self, action):
        if self.done:
            return np.zeros(5), 0, self.done, {}

        reward = 0.0
        prev_price = self.df.loc[self.current_step, 'lastPrice']
        prev_position = self.position

        # Update position: Buy, Sell or Hold
        if action == 1:
            self.position = 1
        elif action == 2:
            self.position = -1

        self.current_step += 1
        if self.current_step >= len(self.df) - 1:
            self.done = True

        curr_price = self.df.loc[self.current_step, 'lastPrice']

        # Reward is pnl: position * price change
        reward = prev_position * (curr_price - prev_price)

        obs = self._get_obs() if not self.done else np.zeros(5)

        return obs, reward, self.done, {}

    def render(self, mode='human'):
        pos_map = {0: "Flat", 1: "Long", -1: "Short"}
        print(f"Step {self.current_step}: Position {pos_map[self.position]}")

# Main function demonstrating each step
def main():
    symbol = "AAPL"
    print(f"Fetching option chain for {symbol}...")

    calls, puts, expiration = fetch_option_chain(symbol)
    print(f"Option expiration used: {expiration}")
    print("Option chain sample:")
    print(calls[['contractSymbol', 'strike', 'lastPrice', 'impliedVolatility']].head())

    # Add underlying price column (latest close price)
    underlying_price = yf.Ticker(symbol).history(period="1d")['Close'].values[-1]
    calls['underlyingPrice'] = underlying_price
    calls['expiration'] = expiration

    # Test Black-Scholes pricing on first option
    row = calls.iloc[0]
    S, K = underlying_price, row['strike']
    T = max((pd.to_datetime(expiration) - pd.to_datetime(datetime.datetime.now().date())).days / 365, 1e-5)
    r = 0.01
    sigma = row['impliedVolatility']
    bs_price = black_scholes_call(S, K, T, r, sigma)
    print(f"\nBlack-Scholes price for first call option:\nCalculated={bs_price:.4f}, Market last price={row['lastPrice']}")

    return calls, puts, expiration

calls, puts, expiration = main()

# Setup RL environment
env = OptionTradingEnv(calls)

# Demonstrate environment reset and sample step
obs = env.reset()
print(f"\nInitial environment observation: {obs}")

# Train PPO agent
!pip install 'shimmy>=2.0'
model = PPO('MlpPolicy', env, verbose=1)
print("\nTraining PPO RL agent on option trading environment...")
model.learn(total_timesteps=5000)

# Test trained agent
obs = env.reset()
done = False
total_reward = 0
print("\nTesting trained agent...")
while not done:
        action, _ = model.predict(obs, deterministic=True)
        obs, reward, done, _ = env.step(action)
        total_reward += reward
        env.render()
print(f"Total reward from RL agent: {total_reward:.4f}")

if __name__ == "__main__":
    main()

# Aligned data arrays of same length (adjust with my data)
n = 100
actual_prices = np.linspace(100, 120, n)                  # Actual prices over time
predicted_prices = actual_prices + np.random.normal(0, 1, n)  # Predicted prices with some noise
pred_volatility = np.abs(np.random.normal(0, 0.05, n))    # Predicted volatility
cumulative_returns = np.cumprod(1 + np.random.normal(0, 0.001, n))  # Simulated cumulative returns

# Plot Actual vs Predicted Prices
plt.figure(figsize=(10, 5))
plt.plot(actual_prices, label='Actual Price')
plt.plot(predicted_prices, label='Predicted Price')
plt.title('Actual vs Predicted Prices')
plt.xlabel('Time')
plt.ylabel('Price')
plt.legend()
plt.grid(True)
plt.show()

# Plot Predicted Volatility
plt.figure(figsize=(10, 5))
plt.plot(pred_volatility, label='Predicted Volatility', color='orange')
plt.title('Predicted Volatility')
plt.xlabel('Time')
plt.ylabel('Volatility')
plt.legend()
plt.grid(True)
plt.show()

# Plot Cumulative Returns of Trading Strategy
plt.figure(figsize=(10, 5))
plt.plot(cumulative_returns, label='Cumulative Returns', color='green')
plt.title('Trading Strategy Cumulative Returns')
plt.xlabel('Time')
plt.ylabel('Returns')
plt.legend()
plt.grid(True)
plt.show()

